<html lang="es">
<head>
<meta charset="UTF-8">
<title>FIRO: TERMINAL EXPLORER</title>
<style>
body {
    background: #000;
    color: #fff;
    font-family: "Lucida Console", "Monaco", monospace;
    font-size: 15px;
    line-height: 1.2;
    margin: 0;
    padding: 20px;
}
.terminal {
    max-width: 80ch;
    width: 100%;
    margin: 0;
    white-space: pre-wrap;
}
.prompt {
    color: #9B1C2E;
}
.input-line {
    display: flex;
    align-items: center;
    margin: 10px 0;
}
#searchInput {
    background: #000;
    color: #fff;
    border: none;
    font-family: "Lucida Console", monospace;
    font-size: 15px;
    padding: 4px 0;
    width: 60ch;
    outline: none;
    caret-color: #9B1C2E;
    autocomplete: off;
}
.footer {
  margin-top: 25px;
  padding-top: 5px;
  color: #fff;
  font-size: 15px;
  line-height: 1.2;
}
a, a:visited {
    color: #9B1C2E;
    text-decoration: none;
}
a:hover {
    text-decoration: underline;
}
.shielded {
    color: #888;
}
pre {
    margin: 10px 0 0 0;
    font-family: "Lucida Console", monospace;
    font-size: 15px;
    white-space: pre-wrap;
    word-wrap: break-word;
    overflow-wrap: break-word;
    max-width: 100%;
}
</style>
</head>
<body>
<div class="terminal">

FIRO TERMINAL EXPLORER
======================<br>
ALTURA       : <span id="stat-height">---</span>
DIFICULTAD   : <span id="stat-difficulty">---</span>
CONEXIONES   : <span id="stat-connections">---</span>
MEMPOOL      : <span id="stat-mempool">---</span> tx
<br><a href="https://carover0.github.io/pagina/firostats.html">[FIRO]</a> <a href="https://carover0.github.io/pagina/firo-consola.html">[CONSOLA]</a><br>
<span class="prompt">Buscar por -></span> <input type="text" id="searchInput" placeholder="bloque / hash / txid / direccion" autofocus>

<div id="output"></div>

===============================================================================
¬© 2026 Creada con ‚ô• por cŒîrovŒ£r0 ¬∑ apoya: carover0.firo
</div>



<script>

const API_URL = "https://carover0.xyz/api/firo/rpc.php";
const TOKEN = "firo2026";
const STATUS_URL = "https://carover0.xyz/api/firo.json";

// ========== DETECCI√ìN AUTOM√ÅTICA ==========
function detectCommand(input) {
    input = input.trim();
    
    if (input.startsWith('getblock') || 
        input.startsWith('getrawtransaction') || 
        input.startsWith('validateaddress') ||
        input.startsWith('getaddressbalance') ||
        input.startsWith('HASH:')) {
        return input;
    }
    
    if (/^\d+$/.test(input)) {
        return `getblockhash ${input}`;
    }
    
    if (/^[a-fA-F0-9]{64}$/.test(input)) {
        return `HASH:${input}`;
    }
    
    if (/^[Ff][a-zA-Z0-9]{33,34}$/.test(input) || /^[aA][a-zA-Z0-9]{33,34}$/.test(input)) {
        return `validateaddress ${input}`;
    }
    
    if (input.length > 50) {
        if (input.startsWith('validateaddress')) {
            return input;
        }
        return `validateaddress ${input}`;
    }
    
    return input;
}

// ========== CARGA DE ESTADOS ==========
async function loadNetworkStats() {
    try {
        const r = await fetch(STATUS_URL);
        const d = await r.json();
        
        document.getElementById('stat-height').innerText = d.blockchain?.blocks?.toLocaleString() || '---';
        document.getElementById('stat-difficulty').innerText = d.blockchain?.difficulty?.toFixed(2) || '---';
        document.getElementById('stat-connections').innerText = d.network?.connections || '---';
        document.getElementById('stat-mempool').innerText = d.mempool?.txcount || '0';
        
    } catch(e) {
        // Silencio
    }
}

// Funci√≥n para obtener valor de una entrada
async function getVinValue(txid, vout) {
    try {
        const r = await fetch(`${API_URL}?token=${TOKEN}&cmd=getrawtransaction%20${txid}%201`);
        const data = await r.json();
        
        if (data.result && data.result.vout && data.result.vout[vout]) {
            return data.result.vout[vout].value;
        }
        return null;
    } catch(e) {
        return null;
    }
}

// ========== EJECUCION DE B√öSQUEDA ==========
async function executeSearch(q) {
    const out = document.getElementById('output');
    out.innerHTML = '<pre>Ejecutando...</pre>';

    // Si es un hash ambiguo 
    if (q.startsWith('HASH:')) {
        const hash = q.substring(5);
        
        // Probar primero como bloque
        try {
            const blockTest = await fetch(`${API_URL}?token=${TOKEN}&cmd=getblock%20${hash}`);
            const blockData = await blockTest.json();
            
            if (blockData.result && blockData.result.hash) {
                return executeSearch(`getblock ${hash}`);
            }
        } catch(e) {
            // Ignorar, probar como transacci√≥n
        }
        
        // Probar como transacci√≥n
        try {
            const txTest = await fetch(`${API_URL}?token=${TOKEN}&cmd=getrawtransaction%20${hash}%201`);
            const txData = await txTest.json();
            
            if (txData.result && txData.result.txid) {
                return executeSearch(`getrawtransaction ${hash} 1`);
            }
        } catch(e) {
            // No es ni bloque ni transacci√≥n
        }
        
        out.innerHTML = `<pre>No se encontr√≥ bloque ni transacci√≥n con hash ${hash}</pre>`;
        document.getElementById('searchInput').value = '';
        return;
    }
    
    try {
        const r = await fetch(`${API_URL}?token=${TOKEN}&cmd=${encodeURIComponent(q)}`);
        const data = await r.json();
        
        let res = `<pre><span style="color:#9B1C2E;">firo> ${q}</span>\n\n`;
        
        if (data.error) {
            res += `error: ${JSON.stringify(data.error)}`;
        } 
        // ===== RESPUESTA DE GETBLOCKHASH =====
        else if (q.includes('getblockhash') && typeof data.result === 'string') {
            const hash = data.result;
            executeSearch(`getblock ${hash}`);
            return;
        }
        // ===== BLOQUES =====
        else if (q.includes('getblock') && data.result?.hash) {
            const b = data.result;
            res += `BLOQUE #${b.height}\n`;
            res += `hash: ${b.hash}\n`;
            res += `fecha: ${new Date(b.time*1000).toLocaleString()}\n`;
            res += `transacciones: ${b.tx?.length || 0}\n`;
            res += `dificultad: ${b.difficulty?.toFixed(2)}\n`;
            if (b.previousblockhash) res += `anterior: ${b.previousblockhash}\n`;
            if (b.nextblockhash) res += `siguiente: ${b.nextblockhash}\n`;
            if (b.size) res += `tama√±o: ${b.size} bytes\n`;
            
            if (b.tx && b.tx.length > 0) {
                res += `\n‚ñ∂ TRANSACCIONES (${b.tx.length})\n`;
                b.tx.forEach((txid, i) => {
                    res += `  ${i+1}. ${txid}\n`;
                });
            }
        }
        // ===== TRANSACCIONES =====
        else if (q.includes('getrawtransaction') && data.result?.txid) {
            const t = data.result;
            const moneda = 'FIRO';
            let totalIn = 0;
            let utxosGastados = 0;
            
            const esBlindada = t.vShieldedSpend?.length > 0 || t.vShieldedOutput?.length > 0;
            
            if (esBlindada) {
                res += `üõ°Ô∏è TRANSACCI√ìN PRIVADA (SHIELDED)\n`;
            } else {
                res += `üìÑ TRANSACCI√ìN TRANSPARENTE\n`;
            }
            res += `TXID: ${t.txid}\n`;
            
            const blockHeight = t.blockheight || t.height || 
                               (t.blockhash ? 'consultar bloque' : 'no confirmada');
            res += `bloque: #${blockHeight}\n`;
            res += `confirmaciones: ${t.confirmations || 0}\n`;
            
            if (t.blocktime || t.time) {
                const ts = t.blocktime || t.time;
                res += `fecha: ${new Date(ts*1000).toLocaleString()}\n`;
            }
            
            res += `versi√≥n: ${t.version || 'N/A'}\n`;
            if (t.size) res += `tama√±o: ${t.size} bytes\n`;
            
            // ----- ENTRADAS TRANSPARENTES (UTXOs GASTADOS) -----
            if (t.vin && t.vin.length > 0) {
                utxosGastados = t.vin.length;
                res += `\n‚ñ∂ ENTRADAS (UTXOs gastados: ${utxosGastados})\n`;
                totalIn = 0;
                
                if (t.vin[0]?.coinbase) {
                    t.vin.forEach((vin, i) => {
                        res += `  [#${i}] COINBASE (nuevos ${moneda})\n`;
                    });
                } else {
                    const vinPromises = t.vin.map(async (vin, i) => {
                        if (vin.txid) {
                            const shortTxid = vin.txid.substring(0, 6) + '...' + vin.txid.substring(59);
                            
                            let value = vin.value;
                            if (!value) {
                                value = await getVinValue(vin.txid, vin.vout);
                            }
                            
                            if (value) totalIn += value;
                            
                            const addrStr = vin.address ? ` (de ${vin.address})` : '';
                            const valStr = value ? ` ${value.toFixed(8)} ${moneda}` : '';
                            return `  [#${i}] ${shortTxid}:${vin.vout}${valStr}${addrStr}`;
                        }
                        return '';
                    });
                    
                    const vinLines = await Promise.all(vinPromises);
                    res += vinLines.filter(line => line !== '').join('\n') + '\n';
                    
                    if (totalIn > 0) {
                        res += `  total entrada: ${totalIn.toFixed(8)} ${moneda}\n`;
                    }
                }
            }
            
            // ----- SALIDAS TRANSPARENTES (UTXOs CREADOS) -----
            if (t.vout && t.vout.length > 0) {
                const utxosCreados = t.vout.length;
                res += `\n‚óÄ SALIDAS (UTXOs creados: ${utxosCreados})\n`;
                let totalOut = 0;
                let pagos = [];
                
                t.vout.forEach((vout, i) => {
                    totalOut += vout.value || 0;
                    let tipo = '';
                    let addr = '';
                    
                    if (vout.scriptPubKey?.type === 'sparkmint') {
                        tipo = ' SPARKMINT';
                        addr = 'Spark Mint (privado)';
                    } else if (vout.scriptPubKey?.addresses?.[0]) {
                        addr = vout.scriptPubKey.addresses[0];
                    } else if (vout.scriptPubKey?.address) {
                        addr = vout.scriptPubKey.address;
                    } else {
                        addr = 'OP_RETURN/privada';
                    }
                    
                    if (addr.length > 64) {
                        addr = addr.substring(0,64) + '...';
                    }
                    
                    pagos.push({
                        index: i,
                        value: vout.value,
                        address: addr,
                        tipo: tipo,
                        raw: `  [#${i}] ${vout.value.toFixed(8)} ${moneda} ‚Üí ${addr}${tipo}`
                    });
                });
                
                // CLASIFICACI√ìN INTELIGENTE
                if (!t.vin[0]?.coinbase && pagos.length >= 2) {
                    const pagosOrdenados = [...pagos].sort((a, b) => b.value - a.value);
                    const pagoPrincipal = pagosOrdenados[0];
                    
                    pagos.forEach(p => {
                        if (p.index === pagoPrincipal.index) {
                            res += `  PAGO: ${p.raw}\n`;
                        } else {
                            res += `  CAMBIO: ${p.raw}\n`;
                        }
                    });
                } else {
                    pagos.forEach(p => {
                        res += `  ${p.raw}\n`;
                    });
                }
                
                if (totalOut > 0) {
                    res += `  total salida: ${totalOut.toFixed(8)} ${moneda}\n`;
                }
                
                // ----- C√ÅLCULO DE FEE -----
                if (!t.vin[0]?.coinbase && totalIn > 0 && totalOut > 0) {
                    const fee = totalIn - totalOut;
                    if (fee > 0) {
                        res += `\n  FEE: ${fee.toFixed(8)} ${moneda}\n`;
                    }
                }
                
                // ----- RESUMEN UTXO -----
                if (!t.vin[0]?.coinbase && totalIn > 0 && totalOut > 0) {
                    const fee = totalIn - totalOut;
                    const haySpark = pagos.some(p => p.tipo.includes('SPARKMINT'));
                    
                    res += `\nRESUMEN UTXO:\n`;
                    res += `   UTXOs gastados: ${utxosGastados} ‚Üí UTXOs creados: ${utxosCreados}\n`;
                    
                    if (pagos.length >= 2) {
                        const pagosOrdenados = [...pagos].sort((a, b) => b.value - a.value);
                        const pagoPrincipal = pagosOrdenados[0];
                        const retornoTotal = pagosOrdenados.slice(1).reduce((sum, p) => sum + p.value, 0);
                        res += `   Pago neto: ${pagoPrincipal.value.toFixed(8)} ${moneda}\n`;
                        res += `   Retorno: ${retornoTotal.toFixed(8)} ${moneda} (${pagos.length-1} UTXO${pagos.length-1 > 1 ? 's' : ''})\n`;
                    } else {
                        res += `   Valor transferido: ${pagos[0].value.toFixed(8)} ${moneda}\n`;
                    }
                    
                    if (haySpark) {
                        res += `   Tipo: Spark Mint (transacci√≥n con privacidad)\n`;
                    }
                    
                    if (fee > 0) {
                        res += `   Fee red: ${fee.toFixed(8)} ${moneda}\n`;
                    }
                }
                
                // ----- RESUMEN PARA COINBASE -----
                if (t.vin[0]?.coinbase) {
                    const pagosOrdenados = [...pagos].sort((a, b) => b.value - a.value);
                    const mayorSalida = pagosOrdenados[0];
                    
                    res += `\nRESUMEN COINBASE:\n`;
                    res += `   Recompensa total: ${totalOut.toFixed(8)} ${moneda}\n`;
                    res += `   Distribuido a ${t.vout.length} direcciones\n`;
                    res += `   Salida mayor: [#${mayorSalida.index}] ${mayorSalida.value.toFixed(8)} ${moneda}\n`;
                }
            }
            
            if (t.vShieldedSpend?.length || t.vShieldedOutput?.length) {
                res += `\nüõ°Ô∏è SHIELDED\n`;
                if (t.vShieldedSpend?.length) res += `  spends: ${t.vShieldedSpend.length}\n`;
                if (t.vShieldedOutput?.length) res += `  outputs: ${t.vShieldedOutput.length}\n`;
            }
        }
        // ===== VALIDACI√ìN DE DIRECCI√ìN =====
        else if (q.includes('validateaddress') && data.result) {
            const v = data.result;
            const direccion = v.address || q.split(' ')[1] || 'desconocida';
            
            res += `DIRECCI√ìN\n`;
            res += `direcci√≥n: ${direccion}\n`;
            
            if (v.isvalidSpark !== undefined) {
                res += `v√°lida (Spark): ${v.isvalidSpark ? 's√≠' : 'no'}\n`;
                if (v.isvalidSpark) {
                    res += `tipo: shielded (Spark)\n`;
                }
            } else {
                res += `v√°lida: ${v.isvalid ? 's√≠' : 'no'}\n`;
                
                if (v.isvalid) {
                    let tipo = 'transparente';
                    if (v.isscript) tipo = 'script';
                    else if (v.iswatchonly) tipo = 'watchonly';
                    res += `tipo: ${tipo}\n`;
                    
                    if (v.scriptPubKey) {
                        res += `scriptPubKey: ${v.scriptPubKey}\n`;
                    }
                }
            }
            
            if (v.ismine !== undefined) {
                res += `pertenece a esta wallet: ${v.ismine ? 's√≠' : 'no'}\n`;
            }
        }
        // ===== CUALQUIER OTRO COMANDO =====
        else {
            res += JSON.stringify(data.result || data, null, 2);
        }
        
        res += '</pre>';
        out.innerHTML = res;
    } catch(e) {
        out.innerHTML = `<pre>error: ${e.message}</pre>`;
    }
    
    document.getElementById('searchInput').value = '';
}

// ========== EVENTOS ==========
const searchInput = document.getElementById('searchInput');

searchInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
        e.preventDefault();
        const rawInput = searchInput.value.trim();
        if (rawInput) {
            const cmd = detectCommand(rawInput);
            executeSearch(cmd);
        }
    }
});

searchInput.addEventListener('paste', (e) => {
    setTimeout(() => {
        const input = searchInput.value;
        const cmd = detectCommand(input);
        if (cmd !== input) {
            searchInput.value = cmd;
        }
    }, 10);
});

// ========== INICIALIZACI√ìN ==========
loadNetworkStats();
setInterval(loadNetworkStats, 30000);
</script>






	
</body>
</html>
