<html lang="es">
<head>
<meta charset="UTF-8">
<title>FIRO: TERMINAL EXPLORER</title>
<style>
body {
    background: #000;
    color: #fff;
    font-family: "Lucida Console", "Monaco", monospace;
    font-size: 15px;
    line-height: 1.2;
    margin: 0;
    padding: 20px;
}
.terminal {
    max-width: 80ch;
    width: 100%;
    margin: 0;
    white-space: pre-wrap;
}
.prompt {
    color: #9B1C2E;
}
.input-line {
    display: flex;
    align-items: center;
    margin: 10px 0;
}
#searchInput {
    background: #000;
    color: #fff;
    border: none;
    font-family: "Lucida Console", monospace;
    font-size: 15px;
    padding: 4px 0;
    width: 60ch;
    outline: none;
    caret-color: #9B1C2E;
    autocomplete: off;
}
.footer {
  margin-top: 25px;
  padding-top: 5px;
  color: #fff;
  font-size: 15px;
  line-height: 1.2;
}
a, a:visited {
    color: #9B1C2E;
    text-decoration: none;
}
a:hover {
    text-decoration: underline;
}
.shielded {
    color: #888;
}
pre {
    margin: 10px 0 0 0;
    font-family: "Lucida Console", monospace;
    font-size: 15px;
    white-space: pre-wrap;
    word-wrap: break-word;
    overflow-wrap: break-word;
    max-width: 100%;
}
</style>
</head>
<body>
<div class="terminal">

FIRO TERMINAL EXPLORER
======================<br>
ALTURA       : <span id="stat-height">---</span>
DIFICULTAD   : <span id="stat-difficulty">---</span>
CONEXIONES   : <span id="stat-connections">---</span>
MEMPOOL      : <span id="stat-mempool">---</span> tx
<br><a href="https://carover0.github.io/pagina/firostats.html">[FIRO]</a> <a href="https://carover0.github.io/pagina/firo-consola.html">[CONSOLA]</a><br>
<span class="prompt">Buscar por -></span> <input type="text" id="searchInput" placeholder="bloque / hash / txid / direccion" autofocus>

<div id="output"></div>

===============================================================================
¬© 2026 Creada con ‚ô• por cŒîrovŒ£r0 ¬∑ apoya: carover0.firo
</div>

<script>


const API_URL = "https://carover0.xyz/api/firo/rpc.php";
const TOKEN = "firo2026";
const STATUS_URL = "https://carover0.xyz/api/firo.json";

// ========== DETECCION AUTOMATICA ==========
function detectCommand(input) {
    input = input.trim();
    
    if (input.startsWith('getblock') || 
        input.startsWith('getrawtransaction') || 
        input.startsWith('validateaddress') ||
        input.startsWith('getaddressbalance') ||
        input.startsWith('HASH:')) {  
        return input;
    }
    
    // 1. Bloque por altura
    if (/^\d+$/.test(input)) {
        return `getblockhash ${input}`;
    }
    
    // 2. HASH DE 64 CARACTERES (sin prefijo)
    if (/^[a-fA-F0-9]{64}$/.test(input)) {
        return `HASH:${input}`;
    }
    
    // 3. Direcci√≥n transparente (F... o a...)
    if (/^[Ff][a-zA-Z0-9]{33,34}$/.test(input) || /^[aA][a-zA-Z0-9]{33,34}$/.test(input)) {
        return `validateaddress ${input}`;
    }
    
    // 4. Direcci√≥n Spark (sm... largo) u otras largas
    if (input.length > 50) {
        if (input.startsWith('validateaddress')) {
            return input;
        }
        return `validateaddress ${input}`;
    }
    
    return input;
}

// ========== CARGA DE ESTADOS ==========
async function loadNetworkStats() {
    try {
        const r = await fetch(STATUS_URL);
        const d = await r.json();
        
        document.getElementById('stat-height').innerText = d.blockchain?.blocks?.toLocaleString() || '---';
        document.getElementById('stat-difficulty').innerText = d.blockchain?.difficulty?.toFixed(2) || '---';
        document.getElementById('stat-connections').innerText = d.network?.connections || '---';
        document.getElementById('stat-mempool').innerText = d.mempool?.txcount || '0';
        
    } catch(e) {
        // NADA
    }
}

// ========== EJECUCION DE BUSQUEDA ==========
async function executeSearch(q) {
    const out = document.getElementById('output');
    out.innerHTML = '<pre>Ejecutando...</pre>';

    // Si es un hash (viene con HASH:)
    if (q.startsWith('HASH:')) {
        const hash = q.substring(5);
        
        // Probar primero como bloque
        try {
            const blockTest = await fetch(`${API_URL}?token=${TOKEN}&cmd=getblock%20${hash}`);
            const blockData = await blockTest.json();
            
            if (blockData.result && blockData.result.hash) {
                // Es un bloque
                return executeSearch(`getblock ${hash}`);
            }
        } catch(e) {
            // Ignorar, probar como transacci√≥n
        }
        
        // Probar como transaccion
        try {
            const txTest = await fetch(`${API_URL}?token=${TOKEN}&cmd=getrawtransaction%20${hash}%201`);
            const txData = await txTest.json();
            
            if (txData.result && txData.result.txid) {
                // Es una transacci√≥n
                return executeSearch(`getrawtransaction ${hash} 1`);
            }
        } catch(e) {
            // No es ni bloque ni transacci√≥n
        }
        
        // Si llegamos ac, no se encontro nada
        out.innerHTML = `<pre>No se encontr√≥ bloque ni transacci√≥n con hash ${hash}</pre>`;
        document.getElementById('searchInput').value = '';
        return;
    }
    
    try {
        const r = await fetch(`${API_URL}?token=${TOKEN}&cmd=${encodeURIComponent(q)}`);
        const data = await r.json();
        
        let res = `<pre><span style="color:#9B1C2E;">firo> ${q}</span>\n\n`;
        
        if (data.error) {
            res += `error: ${JSON.stringify(data.error)}`;
        } 
        // ===== RESPUESTA DE GETBLOCKHASH =====
        else if (q.includes('getblockhash') && typeof data.result === 'string') {
            const hash = data.result;
            executeSearch(`getblock ${hash}`);
            return;
        }
        // ===== BLOQUES =====
        else if (q.includes('getblock') && data.result?.hash) {
            const b = data.result;
            res += `BLOQUE #${b.height}\n`;
            res += `hash: ${b.hash}\n`;
            res += `fecha: ${new Date(b.time*1000).toLocaleString()}\n`;
            res += `transacciones: ${b.tx?.length || 0}\n`;
            res += `dificultad: ${b.difficulty?.toFixed(2)}\n`;
            if (b.previousblockhash) res += `anterior: ${b.previousblockhash}\n`;
            if (b.nextblockhash) res += `siguiente: ${b.nextblockhash}\n`;
            if (b.size) res += `tama√±o: ${b.size} bytes\n`;
            
            if (b.tx && b.tx.length > 0) {
                res += `\n‚ñ∂ TRANSACCIONES (${b.tx.length})\n`;
                b.tx.forEach((txid, i) => {
                    res += `  ${i+1}. ${txid}\n`;
                });
            }
        }
        // ===== TRANSACCIONES =====
        else if (q.includes('getrawtransaction') && data.result?.txid) {
            const t = data.result;
            
            const esBlindada = t.vShieldedSpend?.length > 0 || t.vShieldedOutput?.length > 0;
            
            if (esBlindada) {
                res += `üõ° TRANSACCI√ìN PRIVADA (SHIELDED)\n`;
            } else {
                res += `üìÑ TRANSACCI√ìN TRANSPARENTE\n`;
            }
            res += `TXID: ${t.txid}\n`;
            
            const blockHeight = t.blockheight || t.height || 
                               (t.blockhash ? 'consultar bloque' : 'no confirmada');
            res += `bloque: #${blockHeight}\n`;
            res += `confirmaciones: ${t.confirmations || 0}\n`;
            
            if (t.blocktime || t.time) {
                const ts = t.blocktime || t.time;
                res += `fecha: ${new Date(ts*1000).toLocaleString()}\n`;
            }
            
            res += `versi√≥n: ${t.version || 'N/A'}\n`;
            if (t.size) res += `tama√±o: ${t.size} bytes\n`;
            



// ----- ENTRADAS TRANSPARENTES (UTXOs GASTADOS) -----
let totalIn = 0;
let utxosGastados = 0;
const moneda = 'FIRO';


if (t.vin && t.vin.length > 0) {
    utxosGastados = t.vin.length;
    res += `\n‚ñ∂ ENTRADAS (UTXOs gastados: ${utxosGastados})\n`;
    totalIn = 0;
    
    if (t.vin[0]?.coinbase) {
        t.vin.forEach((vin, i) => {
            res += `  [#${i}] COINBASE (nuevos ${moneda})\n`;
        });
    } else {
        const vinPromises = t.vin.map(async (vin, i) => {
            if (vin.txid) {
                const shortTxid = vin.txid.substring(0, 6) + '...' + vin.txid.substring(59);
                
                let value = vin.value;
                if (!value) {
                    value = await getVinValue(vin.txid, vin.vout);
                }
                
                if (value) totalIn += value;
                
                // Mostrar direcci√≥n de origen si est√° disponible
                const addrStr = vin.address ? ` (de ${vin.address})` : '';
                const valStr = value ? ` ${value.toFixed(8)} ${moneda}` : '';
                return `  [#${i}] ${shortTxid}:${vin.vout}${valStr}${addrStr}`;
            }
            return '';
        });
        
        const vinLines = await Promise.all(vinPromises);
        res += vinLines.filter(line => line !== '').join('\n') + '\n';
        
        if (totalIn > 0) {
            res += `  total entrada: ${totalIn.toFixed(8)} ${moneda}\n`;
        }
    }
}

// ----- SALIDAS TRANSPARENTES (UTXOs CREADOS) -----
if (t.vout && t.vout.length > 0) {
    const utxosCreados = t.vout.length;
    res += `\n‚óÄ SALIDAS (UTXOs creados: ${utxosCreados})\n`;
    let totalOut = 0;
    let pagos = [];
    
    t.vout.forEach((vout, i) => {
        totalOut += vout.value || 0;
        let tipo = '';
        let addr = '';
        
        // Detectar tipo de salida
        if (vout.scriptPubKey?.type === 'sparkmint') {
            tipo = 'SPARKMINT';
            addr = 'Spark Mint (privado)';
        } else if (vout.scriptPubKey?.addresses?.[0]) {
            addr = vout.scriptPubKey.addresses[0];
        } else if (vout.scriptPubKey?.address) {
            addr = vout.scriptPubKey.address;
        } else {
            addr = 'OP_RETURN/privada';
        }
        
        if (addr.length > 64) {
            addr = addr.substring(0,64) + '...';
        }
        
        pagos.push({
            index: i,
            value: vout.value,
            address: addr,
            tipo: tipo,
            raw: `  [#${i}] ${vout.value.toFixed(8)} ${moneda} ‚Üí ${addr}${tipo}`
        });
    });
    
    // CLASIFICACI√ìN INTELIGENTE
    if (!t.vin[0]?.coinbase && pagos.length >= 2) {
        const pagosOrdenados = [...pagos].sort((a, b) => b.value - a.value);
        const pagoPrincipal = pagosOrdenados[0];
        
        pagos.forEach(p => {
            if (p.index === pagoPrincipal.index) {
                res += `  PAGO: ${p.raw}\n`;
            } else {
                res += `  CAMBIO:${p.raw}\n`;
            }
        });
    } else {
        pagos.forEach(p => {
            res += `  ${p.raw}\n`;
        });
    }
    
    if (totalOut > 0) {
        res += `  total salida: ${totalOut.toFixed(8)} ${moneda}\n`;
    }
    
    // ----- C√ÅLCULO DE FEE -----
    if (!t.vin[0]?.coinbase && totalIn > 0 && totalOut > 0) {
        const fee = totalIn - totalOut;
        if (fee > 0) {
            res += `\n  FEE: ${fee.toFixed(8)} ${moneda}\n`;
        }
    }
    
    // ----- AN√ÅLISIS DETALLADO -----
    if (!t.vin[0]?.coinbase && pagos.length >= 2) {
        const pagosOrdenados = [...pagos].sort((a, b) => b.value - a.value);
        const pagoPrincipal = pagosOrdenados[0];
        const retornoTotal = pagosOrdenados.slice(1).reduce((sum, p) => sum + p.value, 0);
        const fee = totalIn - totalOut;
        
        // Detectar si hay Spark Mint
        const haySpark = pagos.some(p => p.tipo.includes('SPARKMINT'));
        
        res += `\nRESUMEN UTXO:\n`;
        res += `   UTXOs gastados: ${utxosGastados} ‚Üí UTXOs creados: ${utxosCreados}\n`;
        res += `   Pago neto: ${pagoPrincipal.value.toFixed(8)} ${moneda}\n`;
        res += `   Retorno: ${retornoTotal.toFixed(8)} ${moneda} (${pagos.length-1} UTXO${pagos.length-1 > 1 ? 's' : ''})\n`;
        if (haySpark) {
            res += `   Tipo: Spark Mint (transacci√≥n con privacidad)\n`;
        }
        if (fee > 0) {
            res += `   Fee red: ${fee.toFixed(8)} ${moneda}\n`;
        }
    }
    
    // ----- RESUMEN PARA COINBASE -----
    if (t.vin[0]?.coinbase) {
        const pagosOrdenados = [...pagos].sort((a, b) => b.value - a.value);
        const mayorSalida = pagosOrdenados[0];
        
        res += `\nRESUMEN COINBASE:\n`;
        res += `   Recompensa total: ${totalOut.toFixed(8)} ${moneda}\n`;
        res += `   Distribuido a ${t.vout.length} direcciones\n`;
        res += `   Salida mayor: [#${mayorSalida.index}] ${mayorSalida.value.toFixed(8)} ${moneda}\n`;
    }
}






			
            
            if (t.vShieldedSpend?.length || t.vShieldedOutput?.length) {
                res += `\nüõ° SHIELDED\n`;
                if (t.vShieldedSpend?.length) res += `  spends: ${t.vShieldedSpend.length}\n`;
                if (t.vShieldedOutput?.length) res += `  outputs: ${t.vShieldedOutput.length}\n`;
            }
            
            if (!esBlindada && t.vin && t.vout) {
                let totalIn = 0;
                t.vin.forEach(vin => { if (vin.value) totalIn += vin.value; });
                let totalOut = t.vout.reduce((sum, v) => sum + (v.value || 0), 0);
                if (totalIn > 0 && totalOut > 0) {
                    const fee = (totalIn - totalOut).toFixed(6);
                    res += `\nfee: ${fee} FIRO\n`;
                }
            }
        }
// ===== VALIDACI√ìN DE DIRECCI√ìN =====
else if (q.includes('validateaddress') && data.result) {
    const v = data.result;
    const direccion = v.address || q.split(' ')[1] || 'desconocida';
    
    res += `DIRECCI√ìN\n`;
    res += `direcci√≥n: ${direccion}\n`;
    
    // Detectar si es Spark
    if (v.isvalidSpark !== undefined) {
        res += `v√°lida (Spark): ${v.isvalidSpark ? 's√≠' : 'no'}\n`;
        if (v.isvalidSpark) {
            res += `tipo: shielded (Spark)\n`;
        }
    } else {
        // Direccion transparente 
        res += `v√°lida: ${v.isvalid ? 's√≠' : 'no'}\n`;
        
        if (v.isvalid) {
            let tipo = 'transparente';
            if (v.isscript) tipo = 'script';
            else if (v.iswatchonly) tipo = 'watchonly';
            res += `tipo: ${tipo}\n`;
            
            // Mostrar scriptPubKey si est√° disponible
            if (v.scriptPubKey) {
                res += `scriptPubKey: ${v.scriptPubKey}\n`;
            }
        }
    }
    
    // Informaci√≥n com√∫n a ambos tipos
    if (v.ismine !== undefined) {
        res += `pertenece a esta wallet: ${v.ismine ? 's√≠' : 'no'}\n`;
    }
}

        // ===== CUALQUIER OTRO COMANDO =====
        else {
            res += JSON.stringify(data.result || data, null, 2);
        }
        
        res += '</pre>';
        out.innerHTML = res;
    } catch(e) {
        out.innerHTML = `<pre>error: ${e.message}</pre>`;
    }
    
    document.getElementById('searchInput').value = '';
}

// ========== EVENTOS ==========
const searchInput = document.getElementById('searchInput');

searchInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
        e.preventDefault();
        const rawInput = searchInput.value.trim();
        if (rawInput) {
            const cmd = detectCommand(rawInput);
            executeSearch(cmd);
        }
    }
});

searchInput.addEventListener('paste', (e) => {
    setTimeout(() => {
        const input = searchInput.value;
        const cmd = detectCommand(input);
        if (cmd !== input) {
            searchInput.value = cmd;
        }
    }, 10);
});

loadNetworkStats();
setInterval(loadNetworkStats, 30000);
</script>
</body>
</html>
