<html lang="es">
<head>
<meta charset="UTF-8">
<title>ZCASH: TERMINAL EXPLORER</title>
<style>
body {
    background: #000;
    color: #fff;
    font-family: "Lucida Console", "Monaco", monospace;
    font-size: 15px;
    line-height: 1.2;
    margin: 0;
    padding: 20px;
}
.terminal {
    max-width: 80ch;
    width: 100%;
    margin: 0;
    white-space: pre-wrap;
}
.prompt {
    color: #DD9D34;
}
.input-line {
    display: flex;
    align-items: center;
    margin: 10px 0;
}
#searchInput {
    background: #000;
    color: #fff;
    border: none;
    font-family: "Lucida Console", monospace;
    font-size: 15px;
    padding: 4px 0;
    width: 60ch;
    outline: none;
    caret-color: #DD9D34;
    autocomplete: off;
}
.footer {
    margin-top: 20px;
    padding-top: 10px;
    color: #777;
}
a, a:visited {
    color: #DD9D34;
    text-decoration: none;
}
a:hover {
    text-decoration: underline;
}
.shielded {
    color: #888;
}
pre {
    margin: 10px 0 0 0;
    font-family: "Lucida Console", monospace;
    font-size: 15px;
    white-space: pre-wrap;
    word-wrap: break-word;
}
</style>
</head>
<body>
<div class="terminal">

EXPLORADOR DE BLOQUES ZCASH
===========================<br>
ALTURA               : <span id="stat-height">---</span>
CONEXIONES           : <span id="stat-connections">---</span>
MEMPOOL              : <span id="stat-mempool">---</span> tx
SERVIDOR LIGHTWALLET : <span id="stat-difficulty">https://carover0.xyz:9067</span>
<br><a href="https://carover0.github.io/pagina/zcashstats.html">[ZCASH]</a> <a href="https://carover0.github.io/pagina/zec-consola.html">[CONSOLA]</a><br>
<span class="prompt">Buscar por -></span> <input type="text" id="searchInput" placeholder="bloque / hash de bloque / txid / direccion" autofocus>

<div id="output"></div>

===============================================================================
Â© 2026 Creada con â™¥ por cÎ”rovÎ£r0 Â· apoya: t1NxVLsRg4kNqMHE2bqmFL5Qizr2JDtmumU
</div>

<script>
const API_URL = "https://carover0.xyz/api/zec/rpc.php";
const TOKEN = "zec2026";
const STATUS_URL = "https://carover0.xyz/zec/status.json";


// ========== DETECCIÃ“N AUTOMÃTICA ==========
function detectCommand(input) {
    input = input.trim();

    if (input.startsWith('getblock') || 
        input.startsWith('getrawtransaction') || 
        input.startsWith('validateaddress') || 
        input.startsWith('z_validateaddress') ||
        input.startsWith('getaddressbalance')) {
        return input;
    }
    if (input.startsWith('u') && input.length > 100) {
        return `UA:${input}`;
    }
    if (/^\d+$/.test(input)) {
        return `getblock ${input}`;
    }
    if (/^[a-fA-F0-9]{64}$/.test(input)) {
        // Si empieza con al menos 4 ceros â†’ es un hash de bloque
        if (/^0{4,}[a-fA-F0-9]*$/.test(input)) {
            return `getblock ${input}`;
        } 
        // Si no â†’ es un txid
        else {
            return `getrawtransaction ${input} 1`;
        }
    }
    if (/^t1[a-zA-Z0-9]{33}$/.test(input)) {
        return `getaddressbalance ${input}`;
    }
    if (input.startsWith('z') && input.length > 50) {
        return `z_getbalance ${input}`;
    }
    return input;
}

// ========== CARGA DE ESTADOS ==========
async function loadNetworkStats() {
    try {
        const r = await fetch(STATUS_URL);
        const d = await r.json();
        
        document.getElementById('stat-height').innerText = d.chain?.height?.toLocaleString() || '---';
        document.getElementById('stat-connections').innerText = d.network?.connections || '---';
        document.getElementById('stat-mempool').innerText = d.mempool?.size || '0';
        
    } catch(e) {
        // NADA
    }
}
// =========== OBTENER VALOR UTXO ==========
async function getVinValue(txid, voutIndex) {
    // Pedir la transacciÃ³n anterior con verbosidad 1 (para tener vouts)
    const prevTx = await fetch(`${API_URL}?token=${TOKEN}&cmd=getrawtransaction ${txid} 1`)
        .then(r => r.json())
        .then(r => r.result);
    
    if (!prevTx || !prevTx.vout || !prevTx.vout[voutIndex]) return null;
    
    // El valor estÃ¡ en prevTx.vout[voutIndex].value
    return prevTx.vout[voutIndex].value;
}

// ========== EJECUCIÃ“N DE BÃšSQUEDA ==========
async function executeSearch(q) {
    const out = document.getElementById('output');
    out.innerHTML = '<pre>Ejecutando...</pre>';


    if (q.startsWith('UA:')) {
        const ua = q.substring(3); 
        let res = `<pre><span style="color:#DD9D34;">zcash> ${ua}</span>\n\n`;
        res += `DIRECCIÃ“N UNIFICADA (UA)\n`;
        res += `direcciÃ³n: ${ua}\n`;
        res += `\n`;
        res += `Las direcciones unificadas pertenecen a una cuenta.\n`;
        res += `Solo se puede consultar su balance si es una cuenta propia.\n`;
        res += `\n`;
        res += `Para validar formato: z_validateaddress ${ua}\n`;
        res += `Para listar receivers: z_listunifiedreceivers ${ua}\n`;
        res += `</pre>`;
        out.innerHTML = res;
        document.getElementById('searchInput').value = '';
        return;
    }

    
    try {
        const r = await fetch(`${API_URL}?token=${TOKEN}&cmd=${encodeURIComponent(q)}`);
        const data = await r.json();
        
        let res = `<pre><span style="color:#DD9D34;">zcash> ${q}</span>\n\n`;
        
        if (data.error) {
            res += `error: ${JSON.stringify(data.error)}`;
        } 
        // ===== BLOQUES =====
        else if (q.includes('getblock') && data.result?.hash) {
            const b = data.result;
            res += `BLOQUE #${b.height}\n`;
            res += `hash: ${b.hash}\n`;
            res += `fecha: ${new Date(b.time*1000).toLocaleString()}\n`;
            res += `transacciones: ${b.tx?.length || 0}\n`;
            res += `dificultad: ${b.difficulty?.toFixed(2)}\n`;
            if (b.previousblockhash) res += `anterior: ${b.previousblockhash}\n`;
            if (b.nextblockhash) res += `siguiente: ${b.nextblockhash}\n`;


            if (b.size) res += `tamaÃ±o: ${b.size} bytes\n`;
            
            // Mostrar transacciones con detalles si estÃ¡n disponibles
            if (b.tx && b.tx.length > 0 && typeof b.tx[0] === 'object') {
                res += `\nâ–¶ TRANSACCIONES (${b.tx.length})\n`;
                b.tx.forEach((tx, i) => {
                    res += `\n  TX #${i+1}: ${tx.txid}\n`;
                    
                    // Calcular total de salidas
                    if (tx.vout && tx.vout.length > 0) {
                        let totalOut = 0;
                        tx.vout.forEach(vout => {
                            totalOut += vout.value || 0;
                        });
                        res += `    total salida: ${totalOut.toFixed(8)} ZEC\n`;
                        
                        // Mostrar todas las salidas
                        tx.vout.forEach((vout, j) => {
                            let addr = 'privada';
                            if (vout.scriptPubKey?.addresses?.[0]) {
                                addr = vout.scriptPubKey.addresses[0];
                                if (addr.length > 64) addr = addr.substring(0,64) + '...';
                            }
                            res += `    â†’ ${vout.value.toFixed(8)} ZEC a ${addr}\n`;
                        });
                    }
                    
                    // Indicar si es blindada
                    const esBlindada = tx.vShieldedSpend?.length > 0 || tx.vShieldedOutput?.length > 0 || tx.orchard?.actions?.length > 0;
                    if (esBlindada) {
                        res += `    ðŸ›¡ incluye ${tx.vShieldedSpend?.length || 0} spends, ${tx.vShieldedOutput?.length || 0} outputs\n`;
                    }
                });
            } else if (b.tx && b.tx.length > 0) {
                // Si solo tenemos TXIDs, mostrar TODOS
                res += `\nâ–¶ TXIDS (${b.tx.length})\n`;
                b.tx.forEach((txid, i) => {
                    res += `  ${i+1}. ${txid}\n`;
                });
            }
        }
        // ===== TRANSACCIONES =====
        else if (q.includes('getrawtransaction') && data.result?.txid) {
            const t = data.result;
            
            // ===== DETECTOR DE TRANSACCIONES BLINDADAS =====
            function esTransaccionBlindada(tx) {
                if (tx.orchard?.actions?.length > 0) return true;
                if (tx.vShieldedSpend?.length > 0) return true;
                if (tx.vShieldedOutput?.length > 0) return true;
                if (tx.vjoinsplit?.length > 0) return true;
                if (tx.bindingSig) return true;
                if (tx.version >= 5 && tx.vin?.length === 0 && tx.vout?.length === 0) return true;
                if (tx.valueBalance !== undefined && tx.valueBalance !== 0) return true;
                return false;
            }
            
            const esBlindada = esTransaccionBlindada(t);
            
            // ----- CABECERA -----
            if (esBlindada) {
                res += `ðŸ›¡ TRANSACCIÃ“N PRIVADA (SHIELDED)\n`;
            } else {
                res += `ðŸ“„ TRANSACCIÃ“N TRANSPARENTE\n`;
            }
            res += `TXID: ${t.txid}\n`;
            
            // Bloque
            const blockHeight = t.blockheight || t.height || 
                               (t.blockhash ? 'consultar bloque' : 'no confirmada');
            res += `bloque: #${blockHeight}\n`;
            res += `confirmaciones: ${t.confirmations || 0}\n`;
            
            // Fecha
            if (t.blocktime || t.time) {
                const ts = t.blocktime || t.time;
                res += `fecha: ${new Date(ts*1000).toLocaleString()}\n`;
            }
            
            // VersiÃ³n y locktime
            res += `versiÃ³n: ${t.version || 'N/A'} Â· locktime: ${t.locktime || 0}\n`;
            
            // TamaÃ±o
            if (t.size) res += `tamaÃ±o: ${t.size} bytes\n`;
            
            // ExpiraciÃ³n
            if (t.expiryheight) {
                if (esBlindada) {
                    res += `privacidad: expira en bloque ${t.expiryheight}\n`;
                } else {
                    res += `expira: bloque ${t.expiryheight}\n`;
                }
            }
            


            // ----- ENTRADAS TRANSPARENTES -----
let totalIn = 0;

if (t.vin && t.vin.length > 0) {
    res += `\nâ–¶ ENTRADAS (UTXOs gastados: ${t.vin.length})\n`;
    totalIn = 0;
    
    const vinPromises = t.vin.map(async (vin, i) => {
        if (vin.coinbase) {
            return `  [#${i}] COINBASE (nuevos ZEC)`;
        } else if (vin.txid) {
            const shortTxid = vin.txid.substring(0,24) + '...' + vin.txid.substring(46);
            
            let value = vin.value;
            if (!value) {
                value = await getVinValue(vin.txid, vin.vout);
            }
            
            if (value) totalIn += value;
            const valStr = value ? ` ${value.toFixed(8)} ZEC` : '';
            return `  [#${i}] desde ${shortTxid}:${vin.vout}${valStr}`;
        }
        return '';
    });
    
    const vinLines = await Promise.all(vinPromises);
    res += vinLines.filter(line => line !== '').join('\n') + '\n';
    
    if (totalIn > 0) {
        res += `  total entradas: ${totalIn.toFixed(8)} ZEC\n`;
    }
} 

// ----- SALIDAS TRANSPARENTES -----
if (t.vout && t.vout.length > 0) {
    res += `\nâ—€ SALIDAS (UTXOs creados: ${t.vout.length})\n`;
    let totalOut = 0;
    let pagos = [];
    
    t.vout.forEach((vout, i) => {
        totalOut += vout.value || 0;
        let addr = 'OP_RETURN/privada';
        if (vout.scriptPubKey?.addresses?.[0]) {
            addr = vout.scriptPubKey.addresses[0];
        } else if (vout.scriptPubKey?.address) {
            addr = vout.scriptPubKey.address;
        }
        if (addr.length > 64) {
            addr = addr.substring(0,64) + '...';
        }
        
        pagos.push({
            index: i,
            value: vout.value,
            address: addr,
            raw: `  [#${i}] ${vout.value.toFixed(8)} ZEC â†’ ${addr}`
        });
    });
    
    // Clasificar pagos vs retornos
    if (pagos.length >= 2) {
        const pagosOrdenados = [...pagos].sort((a, b) => b.value - a.value);
        const pagoPrincipal = pagosOrdenados[0];
        
        pagos.forEach(p => {
            if (p.index === pagoPrincipal.index) {
                res += `  PAGO:      ${p.raw}\n`;
            } else {
                res += `  CAMBIO:   ${p.raw}\n`;
            }
        });
    } else {
        pagos.forEach(p => {
            res += `  ${p.raw}\n`;
        });
    }
    
    if (totalOut > 0) {
        res += `  total salida: ${totalOut.toFixed(8)} ZEC\n`;
    }
    
    // ----- CÃLCULO DE FEE -----
    if (totalIn > 0 && totalOut > 0) {
        const fee = totalIn - totalOut;
        if (fee > 0) {
            res += `\n  FEE: ${fee.toFixed(8)} ZEC\n`;
        }
    }
    
    // ----- RESUMEN UTXO -----
    if (totalIn > 0 && totalOut > 0 && pagos.length >= 2) {
        const pagosOrdenados = [...pagos].sort((a, b) => b.value - a.value);
        const pagoPrincipal = pagosOrdenados[0];
        const retornoTotal = pagosOrdenados.slice(1).reduce((sum, p) => sum + p.value, 0);
        const fee = totalIn - totalOut;
        
        res += `\nRESUMEN UTXO:\n`;
        res += `   ${t.vin.length} UTXOs gastados â†’ ${t.vout.length} UTXOs creados\n`;
        res += `   Pago neto: ${pagoPrincipal.value.toFixed(8)} ZEC\n`;
        res += `   CAMBIO: ${retornoTotal.toFixed(8)} ZEC (nuevo UTXO para el remitente)\n`;
        if (fee > 0) {
            res += `   Fee red: ${fee.toFixed(8)} ZEC\n`;
        }
    }
}

            
            
            // ----- SHIELDED SPROUT -----
            if (t.vjoinsplit && t.vjoinsplit.length > 0) {
                res += `\nðŸ›¡ SPROUT SHIELDED (${t.vjoinsplit.length})\n`;
            }
            
            // ----- SHIELDED SAPLING -----
            if (t.vShieldedSpend?.length || t.vShieldedOutput?.length) {
                res += `\nðŸ›¡ SAPLING SHIELDED\n`;
                if (t.vShieldedSpend?.length) res += `  spends: ${t.vShieldedSpend.length}\n`;
                if (t.vShieldedOutput?.length) res += `  outputs: ${t.vShieldedOutput.length}\n`;
            }
            
            // ----- SHIELDED ORCHARD -----
            if (t.orchard?.actions?.length > 0) {
                res += `\nðŸ›¡ ORCHARD SHIELDED\n`;
                res += `  acciones: ${t.orchard.actions.length}\n`;
                
                t.orchard.actions.forEach((action, i) => {
                    res += `  acciÃ³n #${i+1}:\n`;
                    if (action.nullifier) res += `    nullifier: ${action.nullifier}\n`;
                    if (action.cmx) res += `    commitment: ${action.cmx}\n`;
                });
                
                if (t.orchard.valueBalance && t.orchard.valueBalance !== 0) {
                    res += `  balance: ${t.orchard.valueBalance.toFixed(8)} ZEC\n`;
                }
                if (t.orchard.anchor) {
                    res += `  anchor: ${t.orchard.anchor}\n`;
                }
                if (t.orchard.bindingSig) {
                    res += `  bindingSig: ${t.orchard.bindingSig}\n`;
                }
            }
            
            // ----- BALANCE Y FIRMAS GLOBALES -----
            if (t.valueBalance && t.valueBalance !== 0) {
                const balanceZec = t.valueBalance / 1e8;
                const signo = balanceZec > 0 ? '+' : '';
                res += `\nbalance blindado neto: ${signo}${balanceZec.toFixed(8)} ZEC\n`;
            }
            
            if (t.bindingSig && !t.orchard?.bindingSig) {
                res += `bindingSig: ${t.bindingSig}...\n`;
            }
            
            // ----- FEE -----
            if (!esBlindada && t.vin && t.vout) {
                let totalIn = 0;
                t.vin.forEach(vin => { if (vin.value) totalIn += vin.value; });
                let totalOut = t.vout.reduce((sum, v) => sum + (v.value || 0), 0);
                if (totalIn > 0 && totalOut > 0) {
                    const fee = (totalIn - totalOut).toFixed(8);
                    res += `\nfee: ${fee} ZEC\n`;
                }
            }
        }
        // ===== INFORMACIÃ“N DE DIRECCIÃ“N (UNIFICADA) =====
        else if ((q.includes('getaddressbalance') || q.includes('validateaddress') || q.includes('z_validateaddress')) && data.result) {
            
            const esBalance = q.includes('getaddressbalance');
            const esValidate = q.includes('validateaddress');
            const esZValidate = q.includes('z_validateaddress');

            
            if (esBalance) {
                const b = data.result;
                const direccion = q.split(' ')[1] || b.address || 'desconocida';
                
                res += `DIRECCIÃ“N TRANSPARENTE\n`;
                res += `direcciÃ³n: ${direccion}\n`;
                res += `balance: ${(b.balance / 1e8).toFixed(6)} ZEC\n`;
                
                if (b.received) {
                    res += `recibido (total histÃ³rico): ${(b.received / 1e8).toFixed(6)} ZEC\n`;
                }
                
                if (b.immature) {
                    res += `inmaduro (no gastable): ${(b.immature / 1e8).toFixed(6)} ZEC\n`;
                }
            }
            else if (esValidate || esZValidate) {
                const v = data.result;
                const direccion = v.address || q.split(' ')[1] || 'desconocida';
                
                res += `${esZValidate ? 'Z-ADDRESS (BLINDADA)' : 'DIRECCIÃ“N TRANSPARENTE'}\n`;
                res += `direcciÃ³n: ${direccion}\n`;
                res += `vÃ¡lida: ${v.isvalid ? 'sÃ­' : 'no'}\n`;
                
                if (v.isvalid) {
                    res += `tipo: ${v.isscript ? 'script' : (v.iswatchonly ? 'watchonly' : (esZValidate ? 'shielded' : 'transparente'))}\n`;
                }
                
                if (v.ismine !== undefined) {
                    res += `pertenece a esta wallet: ${v.ismine ? 'sÃ­' : 'no'}\n`;
                }
            }
        } 
        // ===== CUALQUIER OTRO COMANDO =====
        else {
            res += JSON.stringify(data.result || data, null, 2);
        }
        
        res += '</pre>';
        out.innerHTML = res;
    } catch(e) {
        out.innerHTML = `<pre>error: ${e.message}</pre>`;
    }
    
    document.getElementById('searchInput').value = '';
}

    
// ========== EVENTOS ==========
const searchInput = document.getElementById('searchInput');
// enter
searchInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
        e.preventDefault();
        const rawInput = searchInput.value.trim();
        if (rawInput) {
            const cmd = detectCommand(rawInput);
            executeSearch(cmd);
        }
    }
});
// pegar
searchInput.addEventListener('paste', (e) => {
    setTimeout(() => {
        const input = searchInput.value;
        const cmd = detectCommand(input);
        if (cmd !== input) {
            searchInput.value = cmd;
        }
    }, 10);
});

// ========== INICIO ==========
loadNetworkStats();
setInterval(loadNetworkStats, 30000);
</script>
</body>
</html>
